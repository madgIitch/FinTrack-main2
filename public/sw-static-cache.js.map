{"mappings":"AAAA,MAAM,eAAe;AAErB,MAAM,gBAAgB;IACpB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED,6EAA6E;AAC7E,KAAK,gBAAgB,CAAC,WAAW,CAAA;IAC/B,QAAQ,GAAG,CAAC;IACZ,MAAM,SAAS,CACb,OAAO,IAAI,CAAC,cACT,IAAI,CAAC,CAAA,QAAS,MAAM,MAAM,CAAC,gBAC3B,IAAI,CAAC,IAAM,KAAK,WAAW,IAC3B,KAAK,CAAC,CAAA,MAAO,QAAQ,KAAK,CAAC,gCAAgC;AAElE;AAEA,4EAA4E;AAC5E,KAAK,gBAAgB,CAAC,YAAY,CAAA;IAChC,MAAM,SAAS,CACb,OAAO,IAAI,GAAG,IAAI,CAAC,CAAA;QACjB,OAAO,QAAQ,GAAG,CAChB,KACG,MAAM,CAAC,CAAA,MAAO,QAAQ,cACtB,GAAG,CAAC,CAAA,MAAO,OAAO,MAAM,CAAC;IAEhC,GAAG,IAAI,CAAC,IAAM,KAAK,OAAO,CAAC,KAAK;AAEpC;AAEA,4EAA4E;AAC5E,KAAK,gBAAgB,CAAC,SAAS,CAAA;IAC7B,MAAM,MAAM,IAAI,IAAI,MAAM,OAAO,CAAC,GAAG;IACrC,MAAM,WAAW,IAAI,QAAQ;IAE7B,IAAI,MAAM,OAAO,CAAC,MAAM,KAAK,OAC3B,MAAM,WAAW,CACf,OAAO,KAAK,CAAC,MAAM,OAAO,EAAE,IAAI,CAAC,CAAA;QAC/B,+BAA+B;QAC/B,IAAI,QAAQ,OAAO;QAEnB,2BAA2B;QAC3B,OAAO,MAAM,MAAM,OAAO,EAAE,KAAK,CAAC,CAAA;YAChC,QAAQ,IAAI,CAAC,+CAA4C;YAEzD,2DAA2D;YAC3D,IAAI,MAAM,OAAO,CAAC,WAAW,KAAK,YAChC,OAAO,OAAO,KAAK,CAAC;YAGtB,oCAAoC;YACpC,OAAO,IAAI,SAAS,iCAAiC;gBACnD,QAAQ;gBACR,YAAY;YACd;QACF;IACF;AAGN","sources":["sw-static-cache.js"],"sourcesContent":["const STATIC_CACHE = 'static-v1';\r\n\r\nconst STATIC_ASSETS = [\r\n  '/index.html',\r\n  '/manifest.webmanifest',\r\n  '/pages/home.html',\r\n  '/pages/profile.html',\r\n  '/pages/settings.html',\r\n  '/pages/register.html',\r\n  '/pages/notifications.html',\r\n  '/pages/transactions.html',\r\n  '/logoFintonic192x192.c58ee458.png',\r\n];\r\n\r\n// ── Instalar y cachear recursos estáticos ─────────────────────────────────\r\nself.addEventListener('install', event => {\r\n  console.log('[SW STATIC] Instalando y cacheando recursos estáticos');\r\n  event.waitUntil(\r\n    caches.open(STATIC_CACHE)\r\n      .then(cache => cache.addAll(STATIC_ASSETS))\r\n      .then(() => self.skipWaiting())\r\n      .catch(err => console.error('[SW STATIC] Error cacheando:', err))\r\n  );\r\n});\r\n\r\n// ── Activar SW y limpiar caches antiguos si hubiera ──────────────────────\r\nself.addEventListener('activate', event => {\r\n  event.waitUntil(\r\n    caches.keys().then(keys => {\r\n      return Promise.all(\r\n        keys\r\n          .filter(key => key !== STATIC_CACHE)\r\n          .map(key => caches.delete(key))\r\n      );\r\n    }).then(() => self.clients.claim())\r\n  );\r\n});\r\n\r\n// ── Interceptar peticiones ───────────────────────────────────────────────\r\nself.addEventListener('fetch', event => {\r\n  const url = new URL(event.request.url);\r\n  const pathname = url.pathname;\r\n\r\n  if (event.request.method === 'GET') {\r\n    event.respondWith(\r\n      caches.match(event.request).then(cached => {\r\n        // Si está cacheado, devuélvelo\r\n        if (cached) return cached;\r\n\r\n        // Si no, intenta desde red\r\n        return fetch(event.request).catch(err => {\r\n          console.warn('[SW STATIC] Error de red o sin conexión:', err);\r\n          \r\n          // Si es un HTML (página), devolver home.html como fallback\r\n          if (event.request.destination === 'document') {\r\n            return caches.match('/pages/home.html');\r\n          }\r\n\r\n          // Si no es HTML, devolver 503 vacío\r\n          return new Response('Recurso no disponible offline', {\r\n            status: 503,\r\n            statusText: 'Offline',\r\n          });\r\n        });\r\n      })\r\n    );\r\n  }\r\n});\r\n"],"names":[],"version":3,"file":"sw-static-cache.js.map","sourceRoot":"/__parcel_source_root/"}