{"mappings":"IEEI,EACA,EAiPU,EAgDA,C,O,8C,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,E,Q,C,I,E,E,S,E,E,S,E,E,SApSd,IAAM,EAAgB,CAAC,EAAQ,IAAiB,EAAa,IAAI,CAAC,AAAC,GAAM,aAAkB,GAwBrF,EAAqB,IAAI,QACzB,EAAiB,IAAI,QACrB,EAAwB,IAAI,QAgD9B,EAAgB,CAChB,IAAI,CAAM,CAAE,CAAI,CAAE,CAAQ,EACtB,GAAI,aAAkB,eAAgB,CAElC,GAAI,AAAS,SAAT,EACA,OAAO,EAAmB,GAAG,CAAC,GAElC,GAAI,AAAS,UAAT,EACA,OAAO,EAAS,gBAAgB,CAAC,EAAE,CAC7B,KAAA,EACA,EAAS,WAAW,CAAC,EAAS,gBAAgB,CAAC,EAAE,CAE/D,CAEA,OAAO,EAAK,CAAM,CAAC,EAAK,CAC5B,EACA,IAAA,CAAI,EAAQ,EAAM,KACd,CAAM,CAAC,EAAK,CAAG,EACR,CAAA,GAEX,IAAA,CAAI,EAAQ,IACR,AAAI,aAAkB,gBACjB,CAAA,AAAS,SAAT,GAAmB,AAAS,UAAT,CAAS,GAG1B,KAAQ,CAEvB,EAsCA,SAAS,EAAK,CAAK,EAGf,GAAI,aAAiB,WACV,CAnHX,IAAM,EAAU,IAAI,QAAQ,CAAC,EAAS,KAClC,IAAM,EAAW,KACb,AAiHoB,EAjHZ,mBAAmB,CAAC,UAAW,GACvC,AAgHoB,EAhHZ,mBAAmB,CAAC,QAAS,EACzC,EACM,EAAU,KACZ,EAAQ,EAAK,AA6GO,EA7GC,MAAM,GAC3B,GACJ,EACM,EAAQ,KACV,EAAO,AAyGa,EAzGL,KAAK,EACpB,GACJ,EACA,AAsGwB,EAtGhB,gBAAgB,CAAC,UAAW,GACpC,AAqGwB,EArGhB,gBAAgB,CAAC,QAAS,EACtC,GAIA,OADA,EAAsB,GAAG,CAAC,EAiGE,GAhGrB,CA+FP,CAIA,GAAI,EAAe,GAAG,CAAC,GACnB,OAAO,EAAe,GAAG,CAAC,GAC9B,IAAM,EAAW,AArBrB,SAAgC,CAAK,EACjC,GAAI,AAAiB,YAAjB,OAAO,EACP,MAhBJ,AAAI,AAhGI,CAAA,GACH,CAAA,EAAuB,CACpB,UAAU,SAAS,CAAC,OAAO,CAC3B,UAAU,SAAS,CAAC,QAAQ,CAC5B,UAAU,SAAS,CAAC,kBAAkB,CAC1C,AAAC,CAAD,EA2F0B,QAAQ,CAgBd,GAfb,SAAU,GAAG,CAAI,EAIpB,OADA,AAYgB,EAZX,KAAK,CAAC,EAAO,IAAI,EAAG,GAClB,EAAK,IAAI,CAAC,OAAO,CAC5B,EAEG,SAAU,GAAG,CAAI,EAGpB,OAAO,EAAK,AAKQ,EALH,KAAK,CAAC,EAAO,IAAI,EAAG,GACzC,QASA,CAFI,aAAiB,iBACjB,AApFR,SAAwC,CAAE,EAEtC,GAAI,EAAmB,GAAG,CAAC,GACvB,OACJ,IAAM,EAAO,IAAI,QAAQ,CAAC,EAAS,KAC/B,IAAM,EAAW,KACb,EAAG,mBAAmB,CAAC,WAAY,GACnC,EAAG,mBAAmB,CAAC,QAAS,GAChC,EAAG,mBAAmB,CAAC,QAAS,EACpC,EACM,EAAW,KACb,IACA,GACJ,EACM,EAAQ,KACV,EAAO,EAAG,KAAK,EAAI,IAAI,aAAa,aAAc,eAClD,GACJ,EACA,EAAG,gBAAgB,CAAC,WAAY,GAChC,EAAG,gBAAgB,CAAC,QAAS,GAC7B,EAAG,gBAAgB,CAAC,QAAS,EACjC,GAEA,EAAmB,GAAG,CAAC,EAAI,EAC/B,EA4DuC,GAC/B,EAAc,EAhIV,GACH,CAAA,EAAoB,CACjB,YACA,eACA,SACA,UACA,eACJ,AAAC,IA0HM,IAAI,MAAM,EAAO,GAErB,CACX,EAU4C,GAOxC,OAJI,IAAa,IACb,EAAe,GAAG,CAAC,EAAO,GAC1B,EAAsB,GAAG,CAAC,EAAU,IAEjC,CACX,CACA,IAAM,EAAS,AAAC,GAAU,EAAsB,GAAG,CAAC,GAgD9C,EAAc,CAAC,MAAO,SAAU,SAAU,aAAc,QAAQ,CAChE,EAAe,CAAC,MAAO,MAAO,SAAU,QAAQ,CAChD,EAAgB,IAAI,IAC1B,SAAS,EAAU,CAAM,CAAE,CAAI,EAC3B,GAAI,CAAE,CAAA,aAAkB,aACpB,CAAE,CAAA,KAAQ,CAAA,GACV,AAAgB,UAAhB,OAAO,CAAS,EAChB,OAEJ,GAAI,EAAc,GAAG,CAAC,GAClB,OAAO,EAAc,GAAG,CAAC,GAC7B,IAAM,EAAiB,EAAK,OAAO,CAAC,aAAc,IAC5C,EAAW,IAAS,EACpB,EAAU,EAAa,QAAQ,CAAC,GACtC,GAEA,CAAE,CAAA,IAAmB,AAAA,CAAA,EAAW,SAAW,cAAA,EAAgB,SAAS,AAAT,GACvD,CAAE,CAAA,GAAW,EAAY,QAAQ,CAAC,EAAA,EAClC,OAEJ,IAAM,EAAS,eAAgB,CAAS,CAAE,GAAG,CAAI,EAE7C,IAAM,EAAK,IAAI,CAAC,WAAW,CAAC,EAAW,EAAU,YAAc,YAC3D,EAAS,EAAG,KAAK,CAQrB,OAPI,GACA,CAAA,EAAS,EAAO,KAAK,CAAC,EAAK,KAAK,GADpC,EAOQ,AAAA,CAAA,MAAM,QAAQ,GAAG,CAAC,CACtB,CAAM,CAAC,EAAe,IAAI,GAC1B,GAAW,EAAG,IAAI,CACrB,CAAA,CAAE,CAAC,EAAE,AACV,EAEA,OADA,EAAc,GAAG,CAAC,EAAM,GACjB,CACX,CA5II,EA6IwB,IAAd,EA7Ie,CA8IzB,CACA,IAAK,CAAC,EAAQ,EAAM,IAAa,EAAU,EAAQ,IAAS,EAAS,GAAG,CAAC,EAAQ,EAAM,GACvF,IAAK,CAAC,EAAQ,IAAS,CAAC,CAAC,EAAU,EAAQ,IAAS,EAAS,GAAG,CAAC,EAAQ,EAC7E,EAEA,IAAM,EAAqB,CAAC,WAAY,qBAAsB,UAAU,CAClE,EAAY,CAAC,EACb,EAAiB,IAAI,QACrB,EAAmC,IAAI,QACvC,EAAsB,CACxB,IAAI,CAAM,CAAE,CAAI,EACZ,GAAI,CAAC,EAAmB,QAAQ,CAAC,GAC7B,OAAO,CAAM,CAAC,EAAK,CACvB,IAAI,EAAa,CAAS,CAAC,EAAK,CAMhC,OALK,GACD,CAAA,EAAa,CAAS,CAAC,EAAK,CAAG,SAAU,GAAG,CAAI,EAC5C,EAAe,GAAG,CAAC,IAAI,CAAE,EAAiC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAK,IAAI,GACjF,CAAA,EAEG,CACX,CACJ,EACA,eAAgB,EAAQ,GAAG,CAAI,EAE3B,IAAI,EAAS,IAAI,CAIjB,GAHM,aAAkB,WACpB,CAAA,EAAS,MAAM,EAAO,UAAU,IAAI,EADxC,EAGI,CAAC,EACD,OAEJ,IAAM,EAAgB,IAAI,MAAM,EAAQ,GAIxC,IAHA,EAAiC,GAAG,CAAC,EAAe,GAEpD,EAAsB,GAAG,CAAC,EAAe,EAAO,IACzC,GACH,MAAM,EAEN,EAAS,MAAO,CAAA,EAAe,GAAG,CAAC,IAAkB,EAAO,QAAQ,EAAA,EACpE,EAAe,MAAM,CAAC,EAE9B,CACA,SAAS,EAAe,CAAM,CAAE,CAAI,EAChC,OAAS,IAAS,OAAO,aAAa,EAClC,EAAc,EAAQ,CAAC,SAAU,eAAgB,UAAU,GAC1D,AAAS,YAAT,GAAsB,EAAc,EAAQ,CAAC,SAAU,eAAe,CAC/E,CA5LI,EA6LwB,IAAd,EA7Le,CA8LzB,CACA,IAAA,CAAI,EAAQ,EAAM,IACd,AAAI,EAAe,EAAQ,GAChB,EACJ,EAAS,GAAG,CAAC,EAAQ,EAAM,GAEtC,IAAA,CAAI,EAAQ,IACD,EAAe,EAAQ,IAAS,EAAS,GAAG,CAAC,EAAQ,EAEpE,EDzSA,QAAQ,GAAG,CAAC,iCAGZ,IAAM,EAAS,AAA6B,cAA7B,OAAO,QAAQ,CAAC,QAAQ,CACnC,uDACA,4DAKE,EAAa,eAIf,EAAc,EACd,EAAe,EAAE,CAGrB,eAAe,IAEb,OADA,QAAQ,GAAG,CAAC,kCACL,AC6IT,SAAgB,CAAI,CAAE,CAAO,CAAE,CAAA,QAAE,CAAO,CAAA,QAAE,CAAO,CAAA,SAAE,CAAQ,CAAA,WAAE,CAAU,CAAE,CAAG,CAAC,CAAC,EAC1E,IAAM,EAAU,UAAU,IAAI,CAAC,EDzJhB,GC0JT,EAAc,EAAK,GAoBzB,OAnBI,GACA,EAAQ,gBAAgB,CAAC,gBAAiB,AAAC,IACvC,EAAQ,EAAK,EAAQ,MAAM,EAAG,EAAM,UAAU,CAAE,EAAM,UAAU,CAAE,EAAK,EAAQ,WAAW,EAAG,EACjG,GAEA,GACA,EAAQ,gBAAgB,CAAC,UAAW,AAAC,GAAU,EAE/C,EAAM,UAAU,CAAE,EAAM,UAAU,CAAE,IAExC,EACK,IAAI,CAAC,AAAC,IACH,GACA,EAAG,gBAAgB,CAAC,QAAS,IAAM,KACnC,GACA,EAAG,gBAAgB,CAAC,gBAAiB,AAAC,GAAU,EAAS,EAAM,UAAU,CAAE,EAAM,UAAU,CAAE,GAErG,GACK,KAAK,CAAC,KAAQ,GACZ,CACX,EDhLmB,iBACA,EAWkB,CACjC,QAAQ,CAAE,EACJ,EAAG,gBAAgB,CAAC,QAAQ,CAAC,IAC/B,EAAG,iBAAiB,CAAC,GAEvB,EAAG,iBAAiB,CAAC,EAAY,CAAE,QAAS,gBAAiB,EAC/D,CACF,EACF,CAGA,eAAe,EAAkB,CAAG,CAAE,CAAG,EAEvC,IAAK,IAAM,KADX,QAAQ,GAAG,CAAC,mBAAqB,EAAI,MAAM,CAAG,iBAC7B,GAAK,CACpB,IAAM,EAAK,EAAG,cAAc,EAAI,EAAG,EAAE,CACrC,GAAK,GACL,EAAG,cAAc,CAAG,EACpB,GAAI,CACF,MAAM,EAAI,GAAG,CAAC,EAAY,GAC1B,QAAQ,GAAG,CAAC,oBAAqB,EACnC,CAAE,MAAO,EAAG,CACV,QAAQ,KAAK,CAAC,2BAA4B,EAAI,EAChD,EACF,CACF,CAGA,eAAe,EAAgB,CAAM,EACnC,QAAQ,GAAG,CAAC,2CAA4C,GACxD,IAAM,EAAW,MAAM,AAAA,CAAA,EAAA,EAAA,MAAK,AAAL,EAAO,AAAA,CAAA,EAAA,EAAA,GAAE,AAAF,EAAI,EAAA,EAAC,CAAG,QAAS,IACzC,EAAW,EAAS,MAAM,IAAK,EAAS,IAAI,GAAG,KAAK,EAAE,UAAY,EAAE,CAC1E,QAAQ,GAAG,CAAC,oBAAsB,EAAS,MAAM,CAAG,aACpD,IAAM,EAAM,CAAC,EACb,IAAK,GAAM,CAAA,YAAE,CAAW,CAAE,GAAI,EAC5B,GAAI,CACF,IAAM,EAAM,MAAM,MAAM,CAAA,EAAG,EAAO,0BAA0B,CAAC,CAAE,CAC7D,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAmB,EAC9C,KAAM,KAAK,SAAS,CAAC,CAAE,YAAA,CAAY,EACrC,GACA,GAAI,CAAC,EAAI,EAAE,CAAE,CACX,QAAQ,IAAI,CAAC,2CACb,QACF,CAEA,AADa,CAAA,MAAM,EAAI,IAAI,EAA3B,EACK,QAAQ,CAAC,OAAO,CAAC,AAAA,IACpB,CAAG,CAAC,EAAE,UAAU,CAAC,CAAG,EAAE,IAAI,EAAI,SAC9B,QAAQ,GAAG,CAAC,iBAAkB,EAAE,UAAU,CAAE,IAAK,EAAE,IAAI,CACzD,EACF,CAAE,MAAO,EAAG,CACV,QAAQ,KAAK,CAAC,yBAA0B,EAC1C,CAGF,OADA,QAAQ,GAAG,CAAC,oCACL,CACT,CAGA,eAAe,EAA2B,CAAM,EAC9C,QAAQ,GAAG,CAAC,iCAAkC,GAC9C,IAAM,EAAM,MAAM,MAAM,CAAA,EAAG,EAAO,uBAAuB,CAAC,CAAE,CAC1D,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAmB,EAC9C,KAAM,KAAK,SAAS,CAAC,CAAE,OAAA,CAAO,EAChC,GACA,GAAI,CAAC,EAAI,EAAE,CAET,MADA,QAAQ,KAAK,CAAC,8CAA+C,EAAI,MAAM,EACjE,AAAI,MAAM,sCAElB,IAAM,EAAO,MAAM,EAAI,IAAI,GAE3B,OADA,QAAQ,GAAG,CAAC,qBAAuB,EAAK,YAAY,CAAC,MAAM,CAAG,cACvD,EAAK,YAAY,CAAC,GAAG,CAAC,AAAA,GAAO,CAAA,CAClC,GAAG,CAAE,CACL,eAAgB,EAAG,cAAc,EAAI,EAAG,EAAE,AAC5C,CAAA,EACF,CAGA,SAAS,EAAa,CAAE,EACtB,IAAM,EAAM,SAAS,aAAa,CAAC,OAUnC,OATA,EAAI,SAAS,CAAG,mBAChB,EAAI,SAAS,CAAG;AACc,gCAAA,EAAE,EAAG,WAAW,CAAC;AAC3B,sBAAA,EAAE,EAAG,WAAW,CAAC;AAChB,uBAAA,EAAE,IAAI,KAAK,EAAG,IAAI,EAAE,kBAAkB,GAAG;AACxC,wBAAA,EAAE,EAAG,MAAM,CAAG,EAAI,QAAU,SAAS;AACvD,MAAA,EAAE,EAAG,MAAM,CAAG,EAAI,IAAM,IAAA,EAAM,KAAK,GAAG,CAAC,EAAG,MAAM,EAAE,OAAO,CAAC,GAAG;AACnE;AACA,EAAE,CAAC,CACM,CACT,CA0BA,SAAS,IACP,IAAM,EAAM,SAAS,cAAc,CAAC,gBAAgB,KAAK,CACzD,OAAO,EAAM,EAAa,MAAM,CAAC,AAAA,GAAM,EAAG,IAAI,CAAC,UAAU,CAAC,IAAQ,CACpE,CAUA,SAAS,IACP,QAAQ,GAAG,CAAC,uBAAwB,GACpC,IAAM,EAAM,IACZ,QAAQ,GAAG,CAAC,oCAAqC,EAAI,MAAM,EAC3D,IAAM,EAAQ,AAAC,CAAA,EAAc,CAAA,EA5Ib,GA6IV,EAAQ,EAAI,KAAK,CAAC,EAAO,EA7If,GA8IhB,CAAA,SAAS,cAAc,CAAC,eAAe,OAAO,CAC1C,AAtCN,SAA2B,CAAG,EAC5B,IAAM,EAAO,SAAS,cAAc,CAAC,oBACrC,CAAA,EAAK,SAAS,CAAG,GAMjB,OAAO,OAAO,CALC,EAAI,MAAM,CAAC,CAAC,EAAK,KAC9B,IAAM,EAAM,EAAG,QAAQ,EAAI,gBAE3B,MADC,AAAA,CAAA,CAAG,CAAC,EAAI,CAAG,CAAG,CAAC,EAAI,EAAI,EAAC,AAAD,EAAI,IAAI,CAAC,GAC1B,CACT,EAAG,CAAC,IACmB,OAAO,CAAC,CAAC,CAAC,EAAK,EAAM,IAC1C,IAAM,EAAM,SAAS,aAAa,CAAC,MACnC,CAAA,EAAI,SAAS,CAAG,iBAChB,EAAI,SAAS,CAAG,CAAC,IAAI,EAAE,EAAI,KAAK,CAAC,CACjC,EAAM,OAAO,CAAC,AAAA,GAAM,EAAI,WAAW,CAAC,EAAa,KACjD,EAAK,WAAW,CAAC,EACnB,EACF,EAuBwB,GAClB,AA7CN,SAA0B,CAAG,EAC3B,IAAM,EAAO,SAAS,cAAc,CAAC,oBACrC,CAAA,EAAK,SAAS,CAAG,GACjB,EAAI,OAAO,CAAC,AAAA,GAAM,EAAK,WAAW,CAAC,EAAa,IAClD,EAyCuB,GAdrB,IAAM,EAAQ,KAAK,GAAG,CAAC,EAAG,KAAK,IAAI,CAAC,AADtB,IAAiB,MAAM,CAjIrB,IAmIhB,CAAA,SAAS,cAAc,CAAC,aAAa,QAAQ,CAAG,GAAe,EAC/D,SAAS,cAAc,CAAC,aAAa,QAAQ,CAAG,GAAe,EAC/D,SAAS,cAAc,CAAC,aAAa,WAAW,CAAG,CAAC,UAAO,EAAE,EAAY,IAAI,EAAE,EAAA,CAAO,AAaxF,CA4EA,eAAe,EAAiB,CAAM,EACpC,QAAQ,GAAG,CAAC,8BAA+B,GAC/B,MAAM,IAClB,IAAM,EAAa,MAAM,EAAgB,GACzC,QAAQ,GAAG,CAAC,gCAAiC,OAAO,IAAI,CAAC,IAGrD,UAAU,MAAM,GAClB,QAAQ,GAAG,CAAC,4BACZ,MAAM,CAAA,EAAG,EAAO,kCAAkC,CAAC,CAAE,CACnD,OAAQ,OACR,QAAS,CAAE,eAAgB,kBAAmB,EAC9C,KAAM,KAAK,SAAS,CAAC,CAAE,OAAA,CAAO,EAChC,GAAG,KAAK,CAAC,AAAA,GAAK,QAAQ,KAAK,CAAC,eAAgB,KAI9C,IAAI,EAAW,EAAE,CACjB,GAAI,CACF,EAAW,MAAM,EAA2B,EAC9C,CAAE,MAAO,EAAG,CACV,QAAQ,KAAK,CAAC,sBAAuB,EACvC,EAGA,AA/EF,SAA+B,CAAM,CAAE,CAAQ,EAC7C,QAAQ,GAAG,CAAC,qEAAsE,GAClF,IAAM,EAAa,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAA,EAAC,CAAG,QAAS,EAAQ,WAC7C,EAAa,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAA,EAAC,CAAG,QAAS,EAAQ,kBAC/C,EAAa,EAAE,CACb,EAAU,IAAI,IAChB,EAAY,IAAI,IAGpB,SAAS,IACP,EAAW,OAAO,CAAC,AAAA,GAAS,KAC5B,EAAa,EAAE,CACf,EAAQ,KAAK,GACb,IAAM,EAAS,MAAM,IAAI,CAAC,GAAW,IAAI,GACzC,QAAQ,GAAG,CAAC,wBAAyB,GACrC,EAAO,OAAO,CAAC,AAAA,IACb,IAAM,EAAW,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAA,EAAC,CAAG,QAAS,EAAQ,UAAW,EAAS,SACrE,QAAQ,GAAG,CAAC,uCAAwC,GACpD,IAAM,EAAQ,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAU,AAAA,IACjC,QAAQ,GAAG,CAAC,gCAAiC,EAAS,EAAU,UAAU,GAAG,MAAM,CAAE,WACrF,EAAU,UAAU,GAAG,OAAO,CAAC,AAAA,IAC7B,IAAM,EAAU,EAAO,GAAG,CACpB,EAAK,EAAQ,IAAI,GAAG,cAAc,EAAI,EAAQ,EAAE,CACtD,QAAQ,GAAG,CAAC,qBAAsB,EAAO,IAAI,CAAE,SAAU,GACrD,AAAgB,YAAhB,EAAO,IAAI,CACb,EAAQ,MAAM,CAAC,GAEf,EAAQ,GAAG,CAAC,EAAI,CAAE,GAAG,EAAQ,IAAI,EAAE,CAAE,eAAgB,CAAG,EAE5D,GACA,IAAM,EAAU,MAAM,IAAI,CAAC,EAAQ,MAAM,IACzC,QAAQ,GAAG,CAAC,oBAAqB,EAAQ,MAAM,CAAE,qBACjD,EAAS,EACX,EAAG,AAAA,GAAO,QAAQ,KAAK,CAAC,8BAA+B,IACvD,EAAW,IAAI,CAAC,EAClB,EACF,CAGA,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAY,AAAA,IACrB,EAAS,IAAI,CAAC,OAAO,CAAC,AAAA,GAAK,EAAU,GAAG,CAAC,EAAE,EAAE,GAC7C,QAAQ,GAAG,CAAC,kCAAmC,EAAS,IAAI,CAAC,GAAG,CAAC,AAAA,GAAK,EAAE,EAAE,GAC1E,GACF,EAAG,AAAA,GAAO,QAAQ,KAAK,CAAC,gCAAiC,IAGzD,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAY,AAAA,IACrB,EAAQ,IAAI,CAAC,OAAO,CAAC,AAAA,GAAK,EAAU,GAAG,CAAC,EAAE,EAAE,GAC5C,QAAQ,GAAG,CAAC,kCAAmC,EAAQ,IAAI,CAAC,GAAG,CAAC,AAAA,GAAK,EAAE,EAAE,GACzE,GACF,EAAG,AAAA,GAAO,QAAQ,KAAK,CAAC,gCAAiC,GAC3D,EA4BwB,EAAQ,MAAO,IAYnC,GAXA,QAAQ,GAAG,CAAC,gCAAiC,EAAQ,MAAM,EAU3D,QAAQ,GAAG,CAAC,2BAA4B,AALxC,CAAA,EAAe,AAJE,MAAM,IAAI,CACzB,IAAI,IAAI,IAAI,KAAa,EAAQ,CAAC,GAAG,CAAC,AAAA,GAAM,CAAC,EAAG,cAAc,CAAE,EAAG,GAAG,MAAM,IAC5E,IAAI,CAAC,CAAC,EAAG,IAAM,IAAI,KAAK,EAAE,IAAI,EAAI,IAAI,KAAK,EAAE,IAAI,GAE3B,GAAG,CAAC,AAAA,GAAO,CAAA,CACjC,GAAG,CAAE,CACL,YAAa,CAAU,CAAC,EAAG,UAAU,CAAC,EAAI,aAC5C,CAAA,EAAA,EAEqD,MAAM,EACvD,CAAC,OAAO,gBAAgB,CAAE,CA7GhC,QAAQ,GAAG,CAAC,mCACZ,IAAM,EAAK,SAAS,cAAc,CAAC,gBAC7B,EAAK,SAAS,aAAa,CAAC,eAC9B,GAAI,CAAA,EAAG,OAAO,CAAG,IAAO,EAAG,UAAU,CAAG,EAAG,UAAU,GAAK,EAAG,KAAK,EAAtE,EACA,EAAG,QAAQ,CAAG,KAAQ,EAAc,EAAG,GAAY,EACnD,SAAS,cAAc,CAAC,aAAa,OAAO,CAAG,KAC7C,QAAQ,GAAG,CAAC,wBACR,EAAc,IAAK,IAAe,IACxC,EACA,SAAS,cAAc,CAAC,aAAa,OAAO,CAAG,KAC7C,QAAQ,GAAG,CAAC,wBACZ,IAAM,EAAQ,KAAK,IAAI,CAAC,IAAiB,MAAM,CAjKjC,IAkKV,EAAc,IAAS,IAAe,IAC5C,EACA,SAAS,cAAc,CAAC,eAAe,QAAQ,CAAG,KAAQ,EAAc,EAAG,GAAY,EAiGnF,OAAO,gBAAgB,CAAG,CAAA,EAC1B,QAAQ,GAAG,CAAC,wBACd,CACA,IAGA,IAAM,EAAU,MAAM,GACtB,OAAM,EAAkB,EAAS,EACnC,EACF,CAGA,AAAA,CAAA,EAAA,EAAA,kBAAiB,AAAjB,EAAmB,EAAA,IAAG,CAAG,AAAA,IAEvB,GADA,QAAQ,GAAG,CAAC,4BAA6B,GAAM,KAC3C,CAAC,EAAM,OAAQ,OAAO,QAAQ,CAAC,IAAI,CAAG,gBAC1C,EAAiB,EAAK,GAAG,CAC3B,GAGA,OAAO,gBAAgB,CAAC,SAAU,KAChC,QAAQ,GAAG,CAAC,0BACR,AAAA,EAAA,IAAG,CAAE,WAAW,EAAE,EAAiB,AAAA,EAAA,IAAG,CAAE,WAAW,CAAC,GAAG,CAC7D","sources":["<anon>","js/transactions.js","node_modules/idb/build/index.js"],"sourcesContent":["import \"./FinTrack-main.401b9eb7.js\";\n\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire94c2\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire94c2\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\n\nvar $gEjZb = parcelRequire(\"gEjZb\");\n\nvar $6AR8M = parcelRequire(\"6AR8M\");\n\nvar $ilpIi = parcelRequire(\"ilpIi\");\nconst $da032767b57a4aa4$var$instanceOfAny = (object, constructors)=>constructors.some((c)=>object instanceof c);\nlet $da032767b57a4aa4$var$idbProxyableTypes;\nlet $da032767b57a4aa4$var$cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction $da032767b57a4aa4$var$getIdbProxyableTypes() {\n    return $da032767b57a4aa4$var$idbProxyableTypes || ($da032767b57a4aa4$var$idbProxyableTypes = [\n        IDBDatabase,\n        IDBObjectStore,\n        IDBIndex,\n        IDBCursor,\n        IDBTransaction\n    ]);\n}\n// This is a function to prevent it throwing up in node environments.\nfunction $da032767b57a4aa4$var$getCursorAdvanceMethods() {\n    return $da032767b57a4aa4$var$cursorAdvanceMethods || ($da032767b57a4aa4$var$cursorAdvanceMethods = [\n        IDBCursor.prototype.advance,\n        IDBCursor.prototype.continue,\n        IDBCursor.prototype.continuePrimaryKey\n    ]);\n}\nconst $da032767b57a4aa4$var$transactionDoneMap = new WeakMap();\nconst $da032767b57a4aa4$var$transformCache = new WeakMap();\nconst $da032767b57a4aa4$var$reverseTransformCache = new WeakMap();\nfunction $da032767b57a4aa4$var$promisifyRequest(request) {\n    const promise = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = ()=>{\n            resolve($da032767b57a4aa4$export$4997ffc0176396a6(request.result));\n            unlisten();\n        };\n        const error = ()=>{\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    $da032767b57a4aa4$var$reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction $da032767b57a4aa4$var$cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if ($da032767b57a4aa4$var$transactionDoneMap.has(tx)) return;\n    const done = new Promise((resolve, reject)=>{\n        const unlisten = ()=>{\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = ()=>{\n            resolve();\n            unlisten();\n        };\n        const error = ()=>{\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    $da032767b57a4aa4$var$transactionDoneMap.set(tx, done);\n}\nlet $da032767b57a4aa4$var$idbProxyTraps = {\n    get (target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done') return $da032767b57a4aa4$var$transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') return receiver.objectStoreNames[1] ? undefined : receiver.objectStore(receiver.objectStoreNames[0]);\n        }\n        // Else transform whatever we get back.\n        return $da032767b57a4aa4$export$4997ffc0176396a6(target[prop]);\n    },\n    set (target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has (target, prop) {\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store')) return true;\n        return prop in target;\n    }\n};\nfunction $da032767b57a4aa4$var$replaceTraps(callback) {\n    $da032767b57a4aa4$var$idbProxyTraps = callback($da032767b57a4aa4$var$idbProxyTraps);\n}\nfunction $da032767b57a4aa4$var$wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if ($da032767b57a4aa4$var$getCursorAdvanceMethods().includes(func)) return function(...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        func.apply($da032767b57a4aa4$export$debb760848ca95a(this), args);\n        return $da032767b57a4aa4$export$4997ffc0176396a6(this.request);\n    };\n    return function(...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return $da032767b57a4aa4$export$4997ffc0176396a6(func.apply($da032767b57a4aa4$export$debb760848ca95a(this), args));\n    };\n}\nfunction $da032767b57a4aa4$var$transformCachableValue(value) {\n    if (typeof value === 'function') return $da032767b57a4aa4$var$wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction) $da032767b57a4aa4$var$cacheDonePromiseForTransaction(value);\n    if ($da032767b57a4aa4$var$instanceOfAny(value, $da032767b57a4aa4$var$getIdbProxyableTypes())) return new Proxy(value, $da032767b57a4aa4$var$idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction $da032767b57a4aa4$export$4997ffc0176396a6(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest) return $da032767b57a4aa4$var$promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if ($da032767b57a4aa4$var$transformCache.has(value)) return $da032767b57a4aa4$var$transformCache.get(value);\n    const newValue = $da032767b57a4aa4$var$transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        $da032767b57a4aa4$var$transformCache.set(value, newValue);\n        $da032767b57a4aa4$var$reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst $da032767b57a4aa4$export$debb760848ca95a = (value)=>$da032767b57a4aa4$var$reverseTransformCache.get(value);\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */ function $da032767b57a4aa4$export$ca0ed41b1a2af7e(name, version, { blocked: blocked, upgrade: upgrade, blocking: blocking, terminated: terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = $da032767b57a4aa4$export$4997ffc0176396a6(request);\n    if (upgrade) request.addEventListener('upgradeneeded', (event)=>{\n        upgrade($da032767b57a4aa4$export$4997ffc0176396a6(request.result), event.oldVersion, event.newVersion, $da032767b57a4aa4$export$4997ffc0176396a6(request.transaction), event);\n    });\n    if (blocked) request.addEventListener('blocked', (event)=>blocked(// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    openPromise.then((db)=>{\n        if (terminated) db.addEventListener('close', ()=>terminated());\n        if (blocking) db.addEventListener('versionchange', (event)=>blocking(event.oldVersion, event.newVersion, event));\n    }).catch(()=>{});\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */ function $da032767b57a4aa4$export$9d6df0ac66a98bb2(name, { blocked: blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) request.addEventListener('blocked', (event)=>blocked(// Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    return $da032767b57a4aa4$export$4997ffc0176396a6(request).then(()=>undefined);\n}\nconst $da032767b57a4aa4$var$readMethods = [\n    'get',\n    'getKey',\n    'getAll',\n    'getAllKeys',\n    'count'\n];\nconst $da032767b57a4aa4$var$writeMethods = [\n    'put',\n    'add',\n    'delete',\n    'clear'\n];\nconst $da032767b57a4aa4$var$cachedMethods = new Map();\nfunction $da032767b57a4aa4$var$getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === 'string')) return;\n    if ($da032767b57a4aa4$var$cachedMethods.get(prop)) return $da032767b57a4aa4$var$cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = $da032767b57a4aa4$var$writeMethods.includes(targetFuncName);\n    if (// Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || $da032767b57a4aa4$var$readMethods.includes(targetFuncName))) return;\n    const method = async function(storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex) target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done\n        ]))[0];\n    };\n    $da032767b57a4aa4$var$cachedMethods.set(prop, method);\n    return method;\n}\n$da032767b57a4aa4$var$replaceTraps((oldTraps)=>({\n        ...oldTraps,\n        get: (target, prop, receiver)=>$da032767b57a4aa4$var$getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n        has: (target, prop)=>!!$da032767b57a4aa4$var$getMethod(target, prop) || oldTraps.has(target, prop)\n    }));\nconst $da032767b57a4aa4$var$advanceMethodProps = [\n    'continue',\n    'continuePrimaryKey',\n    'advance'\n];\nconst $da032767b57a4aa4$var$methodMap = {};\nconst $da032767b57a4aa4$var$advanceResults = new WeakMap();\nconst $da032767b57a4aa4$var$ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst $da032767b57a4aa4$var$cursorIteratorTraps = {\n    get (target, prop) {\n        if (!$da032767b57a4aa4$var$advanceMethodProps.includes(prop)) return target[prop];\n        let cachedFunc = $da032767b57a4aa4$var$methodMap[prop];\n        if (!cachedFunc) cachedFunc = $da032767b57a4aa4$var$methodMap[prop] = function(...args) {\n            $da032767b57a4aa4$var$advanceResults.set(this, $da032767b57a4aa4$var$ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n        };\n        return cachedFunc;\n    }\n};\nasync function* $da032767b57a4aa4$var$iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) cursor = await cursor.openCursor(...args);\n    if (!cursor) return;\n    cursor;\n    const proxiedCursor = new Proxy(cursor, $da032767b57a4aa4$var$cursorIteratorTraps);\n    $da032767b57a4aa4$var$ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    $da032767b57a4aa4$var$reverseTransformCache.set(proxiedCursor, $da032767b57a4aa4$export$debb760848ca95a(cursor));\n    while(cursor){\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await ($da032767b57a4aa4$var$advanceResults.get(proxiedCursor) || cursor.continue());\n        $da032767b57a4aa4$var$advanceResults.delete(proxiedCursor);\n    }\n}\nfunction $da032767b57a4aa4$var$isIteratorProp(target, prop) {\n    return prop === Symbol.asyncIterator && $da032767b57a4aa4$var$instanceOfAny(target, [\n        IDBIndex,\n        IDBObjectStore,\n        IDBCursor\n    ]) || prop === 'iterate' && $da032767b57a4aa4$var$instanceOfAny(target, [\n        IDBIndex,\n        IDBObjectStore\n    ]);\n}\n$da032767b57a4aa4$var$replaceTraps((oldTraps)=>({\n        ...oldTraps,\n        get (target, prop, receiver) {\n            if ($da032767b57a4aa4$var$isIteratorProp(target, prop)) return $da032767b57a4aa4$var$iterate;\n            return oldTraps.get(target, prop, receiver);\n        },\n        has (target, prop) {\n            return $da032767b57a4aa4$var$isIteratorProp(target, prop) || oldTraps.has(target, prop);\n        }\n    }));\n\n\nconsole.log('[Init] transactions.js loaded');\n// API base URL\nconst $a31a9a86ae321d79$var$apiUrl = window.location.hostname === 'localhost' ? 'http://localhost:5001/fintrack-1bced/us-central1/api' : 'https://us-central1-fintrack-1bced.cloudfunctions.net/api';\n// IndexedDB configuration\nconst $a31a9a86ae321d79$var$DB_NAME = 'fintrack-cache';\nconst $a31a9a86ae321d79$var$DB_VERSION = 8; // bump when data model changes\nconst $a31a9a86ae321d79$var$STORE_NAME = 'transactions';\n// Pagination settings\nconst $a31a9a86ae321d79$var$PAGE_SIZE = 20;\nlet $a31a9a86ae321d79$var$currentPage = 1;\nlet $a31a9a86ae321d79$var$allTxsGlobal = [];\n// Initialize or upgrade IndexedDB\nasync function $a31a9a86ae321d79$var$initDB() {\n    console.log('[DB] Initializing IndexedDB v' + $a31a9a86ae321d79$var$DB_VERSION);\n    return (0, $da032767b57a4aa4$export$ca0ed41b1a2af7e)($a31a9a86ae321d79$var$DB_NAME, $a31a9a86ae321d79$var$DB_VERSION, {\n        upgrade (db) {\n            if (db.objectStoreNames.contains($a31a9a86ae321d79$var$STORE_NAME)) db.deleteObjectStore($a31a9a86ae321d79$var$STORE_NAME);\n            db.createObjectStore($a31a9a86ae321d79$var$STORE_NAME, {\n                keyPath: 'transaction_id'\n            });\n        }\n    });\n}\n// Cache transactions to IndexedDB\nasync function $a31a9a86ae321d79$var$cacheTransactions(idb, txs) {\n    console.log('[Cache] Storing ' + txs.length + ' transactions');\n    for (const tx of txs){\n        const id = tx.transaction_id || tx.id;\n        if (!id) continue;\n        tx.transaction_id = id;\n        try {\n            await idb.put($a31a9a86ae321d79$var$STORE_NAME, tx);\n            console.log('[Cache] Stored tx', id);\n        } catch (e) {\n            console.error('[Cache] Error storing tx', id, e);\n        }\n    }\n}\n// Build account ID → name map\nasync function $a31a9a86ae321d79$var$buildAccountMap(userId) {\n    console.log('[Accounts] Building account map for user', userId);\n    const userSnap = await (0, $ilpIi.getDoc)((0, $ilpIi.doc)((0, $gEjZb.db), 'users', userId));\n    const accounts = userSnap.exists() ? userSnap.data().plaid?.accounts || [] : [];\n    console.log('[Accounts] Found ' + accounts.length + ' accounts');\n    const map = {};\n    for (const { accessToken: accessToken } of accounts)try {\n        const res = await fetch(`${$a31a9a86ae321d79$var$apiUrl}/plaid/get_account_details`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                accessToken: accessToken\n            })\n        });\n        if (!res.ok) {\n            console.warn('[Accounts] accountsGet responded not ok');\n            continue;\n        }\n        const data = await res.json();\n        data.accounts.forEach((a)=>{\n            map[a.account_id] = a.name || 'Cuenta';\n            console.log('[Accounts] Map', a.account_id, \"\\u2192\", a.name);\n        });\n    } catch (e) {\n        console.error('[Accounts] fetch error', e);\n    }\n    console.log('[Accounts] Completed account map');\n    return map;\n}\n// Fetch transactions from Plaid\nasync function $a31a9a86ae321d79$var$fetchTransactionsFromPlaid(userId) {\n    console.log('[Fetch] Plaid transactions for', userId);\n    const res = await fetch(`${$a31a9a86ae321d79$var$apiUrl}/plaid/get_transactions`, {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n            userId: userId\n        })\n    });\n    if (!res.ok) {\n        console.error('[Fetch] Failed to fetch Plaid transactions:', res.status);\n        throw new Error('Failed fetching Plaid transactions');\n    }\n    const data = await res.json();\n    console.log('[Fetch] Retrieved ' + data.transactions.length + ' Plaid txs');\n    return data.transactions.map((tx)=>({\n            ...tx,\n            transaction_id: tx.transaction_id || tx.id\n        }));\n}\n// Rendering helpers\nfunction $a31a9a86ae321d79$var$renderTxItem(tx) {\n    const div = document.createElement('div');\n    div.className = 'transaction-item';\n    div.innerHTML = `\n    <span class=\"account-label\">${tx.accountName}</span>\n    <div class=\"desc\">${tx.description}</div>\n    <span class=\"date\">${new Date(tx.date).toLocaleDateString()}</span>\n    <span class=\"amount ${tx.amount < 0 ? 'debit' : 'credit'}\">\n      ${tx.amount < 0 ? '-' : '+'}${Math.abs(tx.amount).toFixed(2)} \\u{20AC}\n    </span>\n  `;\n    return div;\n}\nfunction $a31a9a86ae321d79$var$renderChronoPage(txs) {\n    const list = document.getElementById('transactions-list');\n    list.innerHTML = '';\n    txs.forEach((tx)=>list.appendChild($a31a9a86ae321d79$var$renderTxItem(tx)));\n}\nfunction $a31a9a86ae321d79$var$renderGroupedPage(txs) {\n    const list = document.getElementById('transactions-list');\n    list.innerHTML = '';\n    const groups = txs.reduce((acc, tx)=>{\n        const cat = tx.category || \"Sin categor\\xeda\";\n        (acc[cat] = acc[cat] || []).push(tx);\n        return acc;\n    }, {});\n    Object.entries(groups).forEach(([cat, items])=>{\n        const sec = document.createElement('div');\n        sec.className = 'category-group';\n        sec.innerHTML = `<h3>${cat}</h3>`;\n        items.forEach((tx)=>sec.appendChild($a31a9a86ae321d79$var$renderTxItem(tx)));\n        list.appendChild(sec);\n    });\n}\n// Filtering & pagination\nfunction $a31a9a86ae321d79$var$getFilteredTxs() {\n    const val = document.getElementById('month-filter').value;\n    return val ? $a31a9a86ae321d79$var$allTxsGlobal.filter((tx)=>tx.date.startsWith(val)) : $a31a9a86ae321d79$var$allTxsGlobal;\n}\nfunction $a31a9a86ae321d79$var$updatePagination() {\n    const total = $a31a9a86ae321d79$var$getFilteredTxs().length;\n    const pages = Math.max(1, Math.ceil(total / $a31a9a86ae321d79$var$PAGE_SIZE));\n    document.getElementById('prev-page').disabled = $a31a9a86ae321d79$var$currentPage <= 1;\n    document.getElementById('next-page').disabled = $a31a9a86ae321d79$var$currentPage >= pages;\n    document.getElementById('page-info').textContent = `P\\xe1gina ${$a31a9a86ae321d79$var$currentPage} de ${pages}`;\n}\nfunction $a31a9a86ae321d79$var$showPage() {\n    console.log('[UI] showPage - page', $a31a9a86ae321d79$var$currentPage);\n    const arr = $a31a9a86ae321d79$var$getFilteredTxs();\n    console.log('[UI] showPage - filtered tx count', arr.length);\n    const start = ($a31a9a86ae321d79$var$currentPage - 1) * $a31a9a86ae321d79$var$PAGE_SIZE;\n    const slice = arr.slice(start, start + $a31a9a86ae321d79$var$PAGE_SIZE);\n    document.getElementById('toggle-view').checked ? $a31a9a86ae321d79$var$renderGroupedPage(slice) : $a31a9a86ae321d79$var$renderChronoPage(slice);\n    $a31a9a86ae321d79$var$updatePagination();\n}\n// UI event listeners\nfunction $a31a9a86ae321d79$var$setupEventListeners() {\n    console.log('[UI] Setting up event listeners');\n    const mf = document.getElementById('month-filter');\n    const mi = document.querySelector('.month-icon');\n    if (mi) mi.onclick = ()=>mf.showPicker ? mf.showPicker() : mf.focus();\n    mf.onchange = ()=>{\n        $a31a9a86ae321d79$var$currentPage = 1;\n        $a31a9a86ae321d79$var$showPage();\n    };\n    document.getElementById('prev-page').onclick = ()=>{\n        console.log('[UI] Prev page click');\n        if ($a31a9a86ae321d79$var$currentPage > 1) {\n            $a31a9a86ae321d79$var$currentPage--;\n            $a31a9a86ae321d79$var$showPage();\n        }\n    };\n    document.getElementById('next-page').onclick = ()=>{\n        console.log('[UI] Next page click');\n        const pages = Math.ceil($a31a9a86ae321d79$var$getFilteredTxs().length / $a31a9a86ae321d79$var$PAGE_SIZE);\n        if ($a31a9a86ae321d79$var$currentPage < pages) {\n            $a31a9a86ae321d79$var$currentPage++;\n            $a31a9a86ae321d79$var$showPage();\n        }\n    };\n    document.getElementById('toggle-view').onchange = ()=>{\n        $a31a9a86ae321d79$var$currentPage = 1;\n        $a31a9a86ae321d79$var$showPage();\n    };\n}\n// Subscribe to Firestore history items in real-time (combining history and historySummary months)\nfunction $a31a9a86ae321d79$var$subscribeHistoryItems(userId, callback) {\n    console.log('[Seed] Initializing subscription to history and summary months for', userId);\n    const historyRef = (0, $ilpIi.collection)((0, $gEjZb.db), 'users', userId, 'history');\n    const summaryRef = (0, $ilpIi.collection)((0, $gEjZb.db), 'users', userId, 'historySummary');\n    let itemUnsubs = [];\n    const seedMap = new Map();\n    let monthsSet = new Set();\n    // Helper to resubscribe to item subcollections based on current monthsSet\n    function resubscribeItems() {\n        itemUnsubs.forEach((unsub)=>unsub());\n        itemUnsubs = [];\n        seedMap.clear();\n        const months = Array.from(monthsSet).sort();\n        console.log('[Seed] Active months:', months);\n        months.forEach((monthId)=>{\n            const itemsRef = (0, $ilpIi.collection)((0, $gEjZb.db), 'users', userId, 'history', monthId, 'items');\n            console.log('[Seed] Subscribing to items of month', monthId);\n            const unsub = (0, $ilpIi.onSnapshot)(itemsRef, (itemsSnap)=>{\n                console.log('[Seed] Item changes for month', monthId, itemsSnap.docChanges().length, 'changes');\n                itemsSnap.docChanges().forEach((change)=>{\n                    const docSnap = change.doc;\n                    const id = docSnap.data().transaction_id || docSnap.id;\n                    console.log('[Seed] change type', change.type, 'for tx', id);\n                    if (change.type === 'removed') seedMap.delete(id);\n                    else seedMap.set(id, {\n                        ...docSnap.data(),\n                        transaction_id: id\n                    });\n                });\n                const seedTxs = Array.from(seedMap.values());\n                console.log('[Seed] Delivering', seedTxs.length, 'seed transactions');\n                callback(seedTxs);\n            }, (err)=>console.error('[Seed] items snapshot error', err));\n            itemUnsubs.push(unsub);\n        });\n    }\n    // Listen to history collection for monthDocs\n    (0, $ilpIi.onSnapshot)(historyRef, (histSnap)=>{\n        histSnap.docs.forEach((d)=>monthsSet.add(d.id));\n        console.log('[Seed] history months snapshot:', histSnap.docs.map((d)=>d.id));\n        resubscribeItems();\n    }, (err)=>console.error('[Seed] history snapshot error', err));\n    // Listen to historySummary collection for monthDocs\n    (0, $ilpIi.onSnapshot)(summaryRef, (sumSnap)=>{\n        sumSnap.docs.forEach((d)=>monthsSet.add(d.id));\n        console.log('[Seed] summary months snapshot:', sumSnap.docs.map((d)=>d.id));\n        resubscribeItems();\n    }, (err)=>console.error('[Seed] summary snapshot error', err));\n}\n// Main load function\nasync function $a31a9a86ae321d79$var$loadTransactions(userId) {\n    console.log('[Main] loadTransactions for', userId);\n    const idb = await $a31a9a86ae321d79$var$initDB();\n    const accountMap = await $a31a9a86ae321d79$var$buildAccountMap(userId);\n    console.log('[Main] Got account map, keys:', Object.keys(accountMap));\n    // Sync remote\n    if (navigator.onLine) {\n        console.log('[Main] Syncing remote...');\n        fetch(`${$a31a9a86ae321d79$var$apiUrl}/plaid/sync_transactions_and_store`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                userId: userId\n            })\n        }).catch((e)=>console.error('[Sync] Error', e));\n    }\n    // Fetch Plaid transactions once\n    let plaidTxs = [];\n    try {\n        plaidTxs = await $a31a9a86ae321d79$var$fetchTransactionsFromPlaid(userId);\n    } catch (e) {\n        console.error('[Fetch] Plaid error', e);\n    }\n    // Subscribe to Firestore seed transactions\n    $a31a9a86ae321d79$var$subscribeHistoryItems(userId, async (seedTxs)=>{\n        console.log('[Main] Received seedTxs count', seedTxs.length);\n        const combined = Array.from(new Map([\n            ...plaidTxs,\n            ...seedTxs\n        ].map((tx)=>[\n                tx.transaction_id,\n                tx\n            ])).values()).sort((a, b)=>new Date(b.date) - new Date(a.date));\n        $a31a9a86ae321d79$var$allTxsGlobal = combined.map((tx)=>({\n                ...tx,\n                accountName: accountMap[tx.account_id] || 'Desconocida'\n            }));\n        console.log('[Main] combined tx count', $a31a9a86ae321d79$var$allTxsGlobal.length);\n        if (!window.hasInitializedUI) {\n            $a31a9a86ae321d79$var$setupEventListeners();\n            window.hasInitializedUI = true;\n            console.log('[Main] UI initialized');\n        }\n        $a31a9a86ae321d79$var$showPage();\n        // Cache latest for offline\n        const freshDb = await $a31a9a86ae321d79$var$initDB();\n        await $a31a9a86ae321d79$var$cacheTransactions(freshDb, $a31a9a86ae321d79$var$allTxsGlobal);\n    });\n}\n// Auth listener\n(0, $6AR8M.onAuthStateChanged)((0, $gEjZb.auth), (user)=>{\n    console.log('[Auth] onAuthStateChanged', user?.uid);\n    if (!user) return window.location.href = '../index.html';\n    $a31a9a86ae321d79$var$loadTransactions(user.uid);\n});\n// Re-sync when coming online\nwindow.addEventListener('online', ()=>{\n    console.log('[Network] online event');\n    if ((0, $gEjZb.auth).currentUser) $a31a9a86ae321d79$var$loadTransactions((0, $gEjZb.auth).currentUser.uid);\n});\n\n\n//# sourceMappingURL=transactions.a48ff726.js.map\n","import { auth, db } from './firebase.js';\nimport { onAuthStateChanged } from 'firebase/auth';\nimport { doc, collection, getDoc, onSnapshot } from 'firebase/firestore';\nimport { openDB } from 'idb';\n\nconsole.log('[Init] transactions.js loaded');\n\n// API base URL\nconst apiUrl = window.location.hostname === 'localhost'\n  ? 'http://localhost:5001/fintrack-1bced/us-central1/api'\n  : 'https://us-central1-fintrack-1bced.cloudfunctions.net/api';\n\n// IndexedDB configuration\nconst DB_NAME    = 'fintrack-cache';\nconst DB_VERSION = 8;  // bump when data model changes\nconst STORE_NAME = 'transactions';\n\n// Pagination settings\nconst PAGE_SIZE = 20;\nlet currentPage = 1;\nlet allTxsGlobal = [];\n\n// Initialize or upgrade IndexedDB\nasync function initDB() {\n  console.log('[DB] Initializing IndexedDB v' + DB_VERSION);\n  return openDB(DB_NAME, DB_VERSION, {\n    upgrade(db) {\n      if (db.objectStoreNames.contains(STORE_NAME)) {\n        db.deleteObjectStore(STORE_NAME);\n      }\n      db.createObjectStore(STORE_NAME, { keyPath: 'transaction_id' });\n    }\n  });\n}\n\n// Cache transactions to IndexedDB\nasync function cacheTransactions(idb, txs) {\n  console.log('[Cache] Storing ' + txs.length + ' transactions');\n  for (const tx of txs) {\n    const id = tx.transaction_id || tx.id;\n    if (!id) continue;\n    tx.transaction_id = id;\n    try {\n      await idb.put(STORE_NAME, tx);\n      console.log('[Cache] Stored tx', id);\n    } catch (e) {\n      console.error('[Cache] Error storing tx', id, e);\n    }\n  }\n}\n\n// Build account ID → name map\nasync function buildAccountMap(userId) {\n  console.log('[Accounts] Building account map for user', userId);\n  const userSnap = await getDoc(doc(db, 'users', userId));\n  const accounts = userSnap.exists() ? userSnap.data().plaid?.accounts || [] : [];\n  console.log('[Accounts] Found ' + accounts.length + ' accounts');\n  const map = {};\n  for (const { accessToken } of accounts) {\n    try {\n      const res = await fetch(`${apiUrl}/plaid/get_account_details`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ accessToken })\n      });\n      if (!res.ok) {\n        console.warn('[Accounts] accountsGet responded not ok');\n        continue;\n      }\n      const data = await res.json();\n      data.accounts.forEach(a => {\n        map[a.account_id] = a.name || 'Cuenta';\n        console.log('[Accounts] Map', a.account_id, '→', a.name);\n      });\n    } catch (e) {\n      console.error('[Accounts] fetch error', e);\n    }\n  }\n  console.log('[Accounts] Completed account map');\n  return map;\n}\n\n// Fetch transactions from Plaid\nasync function fetchTransactionsFromPlaid(userId) {\n  console.log('[Fetch] Plaid transactions for', userId);\n  const res = await fetch(`${apiUrl}/plaid/get_transactions`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ userId })\n  });\n  if (!res.ok) {\n    console.error('[Fetch] Failed to fetch Plaid transactions:', res.status);\n    throw new Error('Failed fetching Plaid transactions');\n  }\n  const data = await res.json();\n  console.log('[Fetch] Retrieved ' + data.transactions.length + ' Plaid txs');\n  return data.transactions.map(tx => ({\n    ...tx,\n    transaction_id: tx.transaction_id || tx.id\n  }));\n}\n\n// Rendering helpers\nfunction renderTxItem(tx) {\n  const div = document.createElement('div');\n  div.className = 'transaction-item';\n  div.innerHTML = `\n    <span class=\"account-label\">${tx.accountName}</span>\n    <div class=\"desc\">${tx.description}</div>\n    <span class=\"date\">${new Date(tx.date).toLocaleDateString()}</span>\n    <span class=\"amount ${tx.amount < 0 ? 'debit' : 'credit'}\">\n      ${tx.amount < 0 ? '-' : '+'}${Math.abs(tx.amount).toFixed(2)} €\n    </span>\n  `;\n  return div;\n}\n\nfunction renderChronoPage(txs) {\n  const list = document.getElementById('transactions-list');\n  list.innerHTML = '';\n  txs.forEach(tx => list.appendChild(renderTxItem(tx)));\n}\n\nfunction renderGroupedPage(txs) {\n  const list = document.getElementById('transactions-list');\n  list.innerHTML = '';\n  const groups = txs.reduce((acc, tx) => {\n    const cat = tx.category || 'Sin categoría';\n    (acc[cat] = acc[cat] || []).push(tx);\n    return acc;\n  }, {});\n  Object.entries(groups).forEach(([cat, items]) => {\n    const sec = document.createElement('div');\n    sec.className = 'category-group';\n    sec.innerHTML = `<h3>${cat}</h3>`;\n    items.forEach(tx => sec.appendChild(renderTxItem(tx)));\n    list.appendChild(sec);\n  });\n}\n\n// Filtering & pagination\nfunction getFilteredTxs() {\n  const val = document.getElementById('month-filter').value;\n  return val ? allTxsGlobal.filter(tx => tx.date.startsWith(val)) : allTxsGlobal;\n}\n\nfunction updatePagination() {\n  const total = getFilteredTxs().length;\n  const pages = Math.max(1, Math.ceil(total / PAGE_SIZE));\n  document.getElementById('prev-page').disabled = currentPage <= 1;\n  document.getElementById('next-page').disabled = currentPage >= pages;\n  document.getElementById('page-info').textContent = `Página ${currentPage} de ${pages}`;\n}\n\nfunction showPage() {\n  console.log('[UI] showPage - page', currentPage);\n  const arr = getFilteredTxs();\n  console.log('[UI] showPage - filtered tx count', arr.length);\n  const start = (currentPage - 1) * PAGE_SIZE;\n  const slice = arr.slice(start, start + PAGE_SIZE);\n  document.getElementById('toggle-view').checked\n    ? renderGroupedPage(slice)\n    : renderChronoPage(slice);\n  updatePagination();\n}\n\n// UI event listeners\nfunction setupEventListeners() {\n  console.log('[UI] Setting up event listeners');\n  const mf = document.getElementById('month-filter');\n  const mi = document.querySelector('.month-icon');\n  if (mi) mi.onclick = () => (mf.showPicker ? mf.showPicker() : mf.focus());\n  mf.onchange = () => { currentPage = 1; showPage(); };\n  document.getElementById('prev-page').onclick = () => {\n    console.log('[UI] Prev page click');\n    if (currentPage > 1) { currentPage--; showPage(); }\n  };\n  document.getElementById('next-page').onclick = () => {\n    console.log('[UI] Next page click');\n    const pages = Math.ceil(getFilteredTxs().length / PAGE_SIZE);\n    if (currentPage < pages) { currentPage++; showPage(); }\n  };\n  document.getElementById('toggle-view').onchange = () => { currentPage = 1; showPage(); };\n}\n\n// Subscribe to Firestore history items in real-time (combining history and historySummary months)\nfunction subscribeHistoryItems(userId, callback) {\n  console.log('[Seed] Initializing subscription to history and summary months for', userId);\n  const historyRef = collection(db, 'users', userId, 'history');\n  const summaryRef = collection(db, 'users', userId, 'historySummary');\n  let itemUnsubs = [];\n  const seedMap = new Map();\n  let monthsSet = new Set();\n\n  // Helper to resubscribe to item subcollections based on current monthsSet\n  function resubscribeItems() {\n    itemUnsubs.forEach(unsub => unsub());\n    itemUnsubs = [];\n    seedMap.clear();\n    const months = Array.from(monthsSet).sort();\n    console.log('[Seed] Active months:', months);\n    months.forEach(monthId => {\n      const itemsRef = collection(db, 'users', userId, 'history', monthId, 'items');\n      console.log('[Seed] Subscribing to items of month', monthId);\n      const unsub = onSnapshot(itemsRef, itemsSnap => {\n        console.log('[Seed] Item changes for month', monthId, itemsSnap.docChanges().length, 'changes');\n        itemsSnap.docChanges().forEach(change => {\n          const docSnap = change.doc;\n          const id = docSnap.data().transaction_id || docSnap.id;\n          console.log('[Seed] change type', change.type, 'for tx', id);\n          if (change.type === 'removed') {\n            seedMap.delete(id);\n          } else {\n            seedMap.set(id, { ...docSnap.data(), transaction_id: id });\n          }\n        });\n        const seedTxs = Array.from(seedMap.values());\n        console.log('[Seed] Delivering', seedTxs.length, 'seed transactions');\n        callback(seedTxs);\n      }, err => console.error('[Seed] items snapshot error', err));\n      itemUnsubs.push(unsub);\n    });\n  }\n\n  // Listen to history collection for monthDocs\n  onSnapshot(historyRef, histSnap => {\n    histSnap.docs.forEach(d => monthsSet.add(d.id));\n    console.log('[Seed] history months snapshot:', histSnap.docs.map(d => d.id));\n    resubscribeItems();\n  }, err => console.error('[Seed] history snapshot error', err));\n\n  // Listen to historySummary collection for monthDocs\n  onSnapshot(summaryRef, sumSnap => {\n    sumSnap.docs.forEach(d => monthsSet.add(d.id));\n    console.log('[Seed] summary months snapshot:', sumSnap.docs.map(d => d.id));\n    resubscribeItems();\n  }, err => console.error('[Seed] summary snapshot error', err));\n}\n\n// Main load function\nasync function loadTransactions(userId) {\n  console.log('[Main] loadTransactions for', userId);\n  const idb = await initDB();\n  const accountMap = await buildAccountMap(userId);\n  console.log('[Main] Got account map, keys:', Object.keys(accountMap));\n\n  // Sync remote\n  if (navigator.onLine) {\n    console.log('[Main] Syncing remote...');\n    fetch(`${apiUrl}/plaid/sync_transactions_and_store`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ userId })\n    }).catch(e => console.error('[Sync] Error', e));\n  }\n\n  // Fetch Plaid transactions once\n  let plaidTxs = [];\n  try {\n    plaidTxs = await fetchTransactionsFromPlaid(userId);\n  } catch (e) {\n    console.error('[Fetch] Plaid error', e);\n  }\n\n  // Subscribe to Firestore seed transactions\n  subscribeHistoryItems(userId, async (seedTxs) => {\n    console.log('[Main] Received seedTxs count', seedTxs.length);\n    const combined = Array.from(\n      new Map([...plaidTxs, ...seedTxs].map(tx => [tx.transaction_id, tx])).values()\n    ).sort((a, b) => new Date(b.date) - new Date(a.date));\n\n    allTxsGlobal = combined.map(tx => ({\n      ...tx,\n      accountName: accountMap[tx.account_id] || 'Desconocida'\n    }));\n\n    console.log('[Main] combined tx count', allTxsGlobal.length);\n    if (!window.hasInitializedUI) {\n      setupEventListeners();\n      window.hasInitializedUI = true;\n      console.log('[Main] UI initialized');\n    }\n    showPage();\n\n    // Cache latest for offline\n    const freshDb = await initDB();\n    await cacheTransactions(freshDb, allTxsGlobal);\n  });\n}\n\n// Auth listener\nonAuthStateChanged(auth, user => {\n  console.log('[Auth] onAuthStateChanged', user?.uid);\n  if (!user) return (window.location.href = '../index.html');\n  loadTransactions(user.uid);\n});\n\n// Re-sync when coming online\nwindow.addEventListener('online', () => {\n  console.log('[Network] online event');\n  if (auth.currentUser) loadTransactions(auth.currentUser.uid);\n});\n","const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n"],"names":["$da032767b57a4aa4$var$idbProxyableTypes","$da032767b57a4aa4$var$cursorAdvanceMethods","oldTraps","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","$gEjZb","$6AR8M","$ilpIi","$da032767b57a4aa4$var$instanceOfAny","object","constructors","some","c","$da032767b57a4aa4$var$transactionDoneMap","WeakMap","$da032767b57a4aa4$var$transformCache","$da032767b57a4aa4$var$reverseTransformCache","$da032767b57a4aa4$var$idbProxyTraps","get","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","$da032767b57a4aa4$export$4997ffc0176396a6","set","value","has","IDBRequest","$da032767b57a4aa4$var$promisifyRequest","promise","Promise","resolve","reject","unlisten","request","removeEventListener","success","error","result","addEventListener","newValue","$da032767b57a4aa4$var$transformCachableValue","$da032767b57a4aa4$var$getCursorAdvanceMethods","IDBCursor","prototype","advance","continue","continuePrimaryKey","includes","args","func","apply","$da032767b57a4aa4$export$debb760848ca95a","$da032767b57a4aa4$var$cacheDonePromiseForTransaction","tx","done","complete","DOMException","IDBDatabase","IDBObjectStore","IDBIndex","Proxy","$da032767b57a4aa4$var$readMethods","$da032767b57a4aa4$var$writeMethods","$da032767b57a4aa4$var$cachedMethods","Map","$da032767b57a4aa4$var$getMethod","targetFuncName","replace","useIndex","isWrite","method","storeName","transaction","store","index","shift","all","$da032767b57a4aa4$var$advanceMethodProps","$da032767b57a4aa4$var$methodMap","$da032767b57a4aa4$var$advanceResults","$da032767b57a4aa4$var$ittrProxiedCursorToOriginalProxy","$da032767b57a4aa4$var$cursorIteratorTraps","cachedFunc","$da032767b57a4aa4$var$iterate","cursor","openCursor","proxiedCursor","delete","$da032767b57a4aa4$var$isIteratorProp","Symbol","asyncIterator","console","log","$a31a9a86ae321d79$var$apiUrl","window","location","hostname","$a31a9a86ae321d79$var$STORE_NAME","$a31a9a86ae321d79$var$currentPage","$a31a9a86ae321d79$var$allTxsGlobal","$a31a9a86ae321d79$var$initDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","then","db","catch","contains","deleteObjectStore","createObjectStore","keyPath","$a31a9a86ae321d79$var$cacheTransactions","idb","txs","length","transaction_id","put","e","$a31a9a86ae321d79$var$buildAccountMap","userId","userSnap","getDoc","doc","accounts","exists","data","plaid","map","accessToken","res","fetch","headers","body","JSON","stringify","ok","warn","json","forEach","a","account_id","$a31a9a86ae321d79$var$fetchTransactionsFromPlaid","status","transactions","$a31a9a86ae321d79$var$renderTxItem","div","document","createElement","className","innerHTML","accountName","description","Date","date","toLocaleDateString","amount","Math","abs","toFixed","$a31a9a86ae321d79$var$getFilteredTxs","val","getElementById","filter","startsWith","$a31a9a86ae321d79$var$showPage","arr","start","slice","checked","$a31a9a86ae321d79$var$renderGroupedPage","list","Object","entries","reduce","acc","cat","category","push","items","sec","appendChild","$a31a9a86ae321d79$var$renderChronoPage","pages","max","ceil","total","disabled","textContent","$a31a9a86ae321d79$var$loadTransactions","accountMap","keys","navigator","onLine","plaidTxs","$a31a9a86ae321d79$var$subscribeHistoryItems","callback","historyRef","collection","summaryRef","itemUnsubs","seedMap","monthsSet","Set","resubscribeItems","unsub","clear","months","Array","from","sort","monthId","itemsRef","onSnapshot","itemsSnap","docChanges","change","docSnap","type","seedTxs","values","histSnap","docs","d","add","sumSnap","combined","b","hasInitializedUI","mf","mi","querySelector","onclick","showPicker","focus","onchange","freshDb","onAuthStateChanged","auth","user","uid","href","currentUser"],"version":3,"file":"transactions.a48ff726.js.map"}